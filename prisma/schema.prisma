generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        Int                       @id @default(autoincrement())
  username                  String                    @unique
  password                  String
  hp                        Int
  energy                    Int
  gold                      Int
  attack_power              Int
  current_day               Int
  is_alive                  Boolean                   @default(true)
  role                      String                    @default("user")
  daily_investigation_count DailyInvestigationCount[]
  inventory                 Inventory[]
  investigation_sessions    InvestigationSession[]
  story_progress            StoryProgress[]
  team_members              TeamMember[]
  user_abilities            UserAbility[]
  user_checkpoints          UserCheckpoint[]
  user_resources            UserResource[]
  user_save_states          UserSaveState[]
  user_story_abilities      UserStoryAbility[]
  user_story_items          UserStoryItem[]

  @@map("users")
}

model Story {
  id          Int          @id @default(autoincrement())
  story_type  String
  title       String?
  description String?
  created_at  DateTime     @default(now())
  checkpoints Checkpoint[]
  nodes       Node[]

  @@map("stories")
}

model Node {
  id               Int          @id @default(autoincrement())
  story_id         Int
  node_id          Int
  title            String?
  text_content     String
  image_url        String?
  image_alt        String?
  node_type        String       @default("main")
  position_x       Int?
  position_y       Int?
  created_at       DateTime     @default(now())
  checkpoints      Checkpoint[]
  incoming_choices Choice[]     @relation("ToNode")
  outgoing_choices Choice[]     @relation("FromNode")
  story            Story        @relation(fields: [story_id], references: [id], onDelete: Cascade)

  @@unique([story_id, node_id], map: "sqlite_autoindex_nodes_1")
  @@map("nodes")
}

model Choice {
  id           Int                @id @default(autoincrement())
  from_node_id Int
  to_node_id   Int
  choice_text  String
  order_num    Int                @default(1)
  is_available Boolean            @default(true)
  created_at   DateTime           @default(now())
  constraints  ChoiceConstraint[]
  results      ChoiceResult[]
  to_node      Node               @relation("ToNode", fields: [to_node_id], references: [id], onDelete: Cascade)
  from_node    Node               @relation("FromNode", fields: [from_node_id], references: [id], onDelete: Cascade)

  @@map("choices")
}

model Resource {
  id                 Int                @id @default(autoincrement())
  name               String             @unique(map: "sqlite_autoindex_resources_1")
  description        String?
  type               String
  created_at         DateTime           @default(now())
  choice_constraints ChoiceConstraint[]
  choice_results     ChoiceResult[]
  user_resources     UserResource[]

  @@map("resources")
}

model UserResource {
  id          Int      @id @default(autoincrement())
  user_id     Int
  resource_id Int
  quantity    Int      @default(0)
  obtained_at DateTime @default(now())
  resource    Resource @relation(fields: [resource_id], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, resource_id], map: "sqlite_autoindex_user_resources_1")
  @@map("user_resources")
}

model ChoiceConstraint {
  id              Int      @id @default(autoincrement())
  choice_id       Int
  resource_id     Int
  required_value  Int
  comparison_type String   @default(">=")
  description     String?
  created_at      DateTime @default(now())
  resource        Resource @relation(fields: [resource_id], references: [id], onDelete: Cascade)
  choice          Choice   @relation(fields: [choice_id], references: [id], onDelete: Cascade)

  @@map("choice_constraints")
}

model ChoiceResult {
  id           Int      @id @default(autoincrement())
  choice_id    Int
  resource_id  Int
  value_change Int
  description  String?
  created_at   DateTime @default(now())
  resource     Resource @relation(fields: [resource_id], references: [id], onDelete: Cascade)
  choice       Choice   @relation(fields: [choice_id], references: [id], onDelete: Cascade)

  @@map("choice_results")
}

model Checkpoint {
  id              Int      @id @default(autoincrement())
  story_id        Int
  node_id         Int
  checkpoint_name String
  description     String?
  created_at      DateTime @default(now())
  node            Node     @relation(fields: [node_id], references: [id], onDelete: Cascade)
  story           Story    @relation(fields: [story_id], references: [id], onDelete: Cascade)

  @@unique([story_id, node_id], map: "sqlite_autoindex_checkpoints_1")
  @@map("checkpoints")
}

model UserCheckpoint {
  id          Int      @id @default(autoincrement())
  user_id     Int
  node_id     Int
  title       String
  description String?
  hp          Int
  energy      Int
  gold        Int
  saved_at    DateTime @default(now())
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_checkpoints")
}

model UserSaveState {
  id              Int      @id @default(autoincrement())
  user_id         Int
  story_id        Int
  current_node_id Int
  save_name       String?
  temp_data       String?
  saved_at        DateTime @default(now())
  user            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_save_states")
}

model Item {
  id          Int         @id @default(autoincrement())
  name        String
  description String
  type        ItemType
  inventory   Inventory[]
  raid_items  RaidItem[]

  @@map("items")
}

model Inventory {
  id       Int  @id @default(autoincrement())
  user_id  Int
  item_id  Int
  quantity Int
  item     Item @relation(fields: [item_id], references: [id], onDelete: Cascade)
  user     User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("inventory")
}

model RaidTeam {
  id           Int          @id @default(autoincrement())
  day          Int
  status       RaidStatus
  boss_id      Int
  raid_items   RaidItem[]
  boss         Boss         @relation(fields: [boss_id], references: [id])
  team_members TeamMember[]

  @@map("raid_teams")
}

model TeamMember {
  id      Int      @id @default(autoincrement())
  team_id Int
  user_id Int
  user    User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  team    RaidTeam @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@map("team_members")
}

model RaidItem {
  id       Int      @id @default(autoincrement())
  team_id  Int
  item_id  Int
  quantity Int
  item     Item     @relation(fields: [item_id], references: [id], onDelete: Cascade)
  team     RaidTeam @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@map("raid_items")
}

model Boss {
  id         Int        @id @default(autoincrement())
  name       String
  hp         Int
  skills     String
  raid_teams RaidTeam[]

  @@map("bosses")
}

model Ability {
  id             Int           @id @default(autoincrement())
  name           String
  description    String
  effect_type    String
  effect_value   Int
  user_abilities UserAbility[]

  @@map("abilities")
}

model UserAbility {
  id          Int      @id @default(autoincrement())
  user_id     Int
  ability_id  Int
  is_active   Boolean  @default(false)
  obtained_at DateTime @default(now())
  ability     Ability  @relation(fields: [ability_id], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_abilities")
}

model InvestigationSession {
  id              Int       @id @default(autoincrement())
  user_id         Int
  day             Int
  session_number  Int
  hp              Int       @default(3)
  energy          Int       @default(3)
  gold_start      Int
  gold_end        Int?
  current_node_id Int?
  status          String    @default("active")
  started_at      DateTime  @default(now())
  ended_at        DateTime?
  user            User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("investigation_sessions")
}

model DailyInvestigationCount {
  id         Int      @id @default(autoincrement())
  user_id    Int
  day        Int
  count      Int      @default(0)
  last_reset DateTime @default(now())
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, day], map: "sqlite_autoindex_daily_investigation_count_1")
  @@map("daily_investigation_count")
}

model StoryAbility {
  id                   Int                @id @default(autoincrement())
  name                 String
  description          String
  user_story_abilities UserStoryAbility[]

  @@map("story_abilities")
}

model UserStoryAbility {
  id               Int          @id @default(autoincrement())
  user_id          Int
  story_ability_id Int
  quantity         Int          @default(1)
  obtained_at      DateTime     @default(now())
  story_ability    StoryAbility @relation(fields: [story_ability_id], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_story_abilities")
}

model StoryItem {
  id               Int             @id @default(autoincrement())
  name             String
  description      String?
  created_at       DateTime        @default(now())
  user_story_items UserStoryItem[]

  @@map("story_items")
}

model UserStoryItem {
  id            Int       @id @default(autoincrement())
  user_id       Int
  story_item_id Int
  quantity      Int       @default(1)
  obtained_at   DateTime  @default(now())
  story_item    StoryItem @relation(fields: [story_item_id], references: [id], onDelete: Cascade)
  user          User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_story_items")
}

model RandomStory {
  id           Int     @id @default(autoincrement())
  title        String
  description  String
  choices      String
  outcomes     String
  requirements String?
  category     String?

  @@map("random_stories")
}

model MainStory {
  id            Int           @id @default(autoincrement())
  node_id       Int           @unique
  title         String
  text          String
  node_type     String
  route_name    String?
  choices       String
  rewards       String?
  position_x    Int?
  position_y    Int?
  image_url     String?
  image_alt     String?
  created_at    DateTime      @default(now())
  story_choices StoryChoice[]

  @@map("main_stories")
}

model StoryChoice {
  id                  Int                 @id @default(autoincrement())
  story_node_id       Int
  choice_text         String
  target_node_id      Int?
  order_index         Int                 @default(0)
  is_available        Boolean             @default(true)
  created_at          DateTime            @default(now())
  choice_requirements ChoiceRequirement[]
  story_node          MainStory           @relation(fields: [story_node_id], references: [node_id], onDelete: Cascade)

  @@map("story_choices")
}

model ChoiceRequirement {
  id                Int         @id @default(autoincrement())
  choice_id         Int
  requirement_type  String
  requirement_id    Int?
  requirement_value Int?
  operator          String      @default(">=")
  description       String?
  created_at        DateTime    @default(now())
  choice            StoryChoice @relation(fields: [choice_id], references: [id], onDelete: Cascade)

  @@map("choice_requirements")
}

model StoryProgress {
  id              Int      @id @default(autoincrement())
  user_id         Int
  current_node_id Int      @default(1)
  story_data      String?
  created_at      DateTime @default(now())
  updated_at      DateTime @default(now())
  user            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("story_progress")
}

enum ItemType {
  story
  raid
}

enum RaidStatus {
  ongoing
  cleared
  failed
}
